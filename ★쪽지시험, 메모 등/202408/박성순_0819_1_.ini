유니티
    아이템 생성
        주기적으로 아이템을 생성.
        플레이어 근처의 NavMesh 위에 랜덤한 위치를 선택해서 아이템 생성 위치로 사용. (너무 멀리 생성되지 않도록)
        너무 랜덤하게 생성하는 것이 아니라 기존에 생성된 위치에서 그나마 비슷한 위치에 생성되도록.

    PhotonCloud를 이용한 멀티 플레이어 게임으로 포팅
        최대 4명의 플레이어가 서로 협동하여 좀비를 학살하는 게임
        한 방에 접속한 4명의 플레이어가 접속해서 멀티 플레이어 게임을 한다.

        기본 플레이 구성은 싱글플레이어와 같다.
        싱글 플레이어 게임을 최대 4인 멀티플레이로 포팅한다.
        사망한 플레이어는 5초 후 부활한다.
        매치 메이킹 시스템으로 로비에서 인터넷을 통해 자동으로 빈 방에 접속하여 다른 플레이어와 매치되어 게임을 진행한다.

        LocalPlayer와 RemotePlayer를 구분하여 처리한다.
        네트워크 권한에 따라 코드를 분리하는 방법
        클라이언트 사이에서 수치가 동기화되는 흐름.

        서버는 클라이언트들이 참가하는 네트워크 공간을 마련하는 PC이고, 이를 Host라고 한다.
        서버에 참가해서 게임을 플레이 하는 PC를 Client라고 한다.

        게임 서버의 종류 :
            RPC (Remote Procedure Call) : 원격 프로시저 호출
                클라이언트에서 서버로 요청을 보내고, 서버에서 클라이언트로 응답을 보내는 방식.
            PUN (Photon Unity Networking) : 포톤 유니티 네트워킹
                포톤 클라우드를 이용하여 멀티 플레이어 게임을 구현하는 방식.
                PhotonView :
                    본인 캐릭터의 움직임을 송신하고 다른 네트워크 유저 캐릭터의 움직임을 수신하는 컴포넌트.
                PhotonTransformView :
                    본인 캐릭터의 위치, 회전, 크기를 송신하고 다른 네트워크 유저 캐릭터의 위치, 회전, 크기를 수신하는 컴포넌트.
                PhotinAnimatorView :
                    본인 캐릭터의 애니메이션을 송신하고 다른 네트워크 유저 캐릭터의 애니메이션을 수신하는 컴포넌트.

            Listen Server :
                서버와 클라이언트가 동시에 존재하는 서버.
                서버 역할을 맡은 클라이언트가 게임을 진행하면서, 다른 클라이언트들과 연결되어 게임을 진행하는 방식.
                물리적으로 클라이언트끼리 가까울 때 사용하면 전용 서버보다 빠른 속도로 게임을 진행할 수 있음.
                리슨 서버는 호스트의 PC, 네트워크 환경에 따라 성능이 달라질 수 있음.
                호스트가 게임을 종료하면 진행중인 게임을 일시정지 하여 남은 클라이언트 중 하나가 호스트가 되어 게임을 계속 진행하는 절차가 필요.
                아니라면 게임이 종료되어 버림.
            Dedicated Server : 서버만 존재하는 서버.
            P2P (Peer to Peer) : 1:1 연결 방식
                서버가 존재하지 않고, 클라이언트들이 서로 연결하여 게임을 진행하는 방식.
                서버가 존재하지 않기 때문에 서버 유지 비용이 없으나, 클라이언트들의 연결 상태에 따라 게임 속도가 달라질 수 있음.
                연결이 많아질 수록 네트워크 상태가 불안정해질 수 있음.
                
        
        4명의 멀티플레이어 게임에서는 플레이어 캐릭터는 총 16개가 생성되어야 한다.
        ex) 4명의 플레이어가 각각 4개의 캐릭터를 생성한다. (L,R,R,R), (R,L,R,R), (R,R,L,R), (R,R,R,L) {L = Local, R = Remote}

        LivingEntity.cs 에서 RestoreHP()와 OnDamage() 메서드는 [PunRPC]로 선언하여 네트워크로 동기화한다.
        override하는 측면에서도 [PunRPC]로 선언하여 동기화한다. [PunRPC]는 상속되지 않는다. (override되지 않는다.)
        따라서 PlayerHP.cs의 RestoreHP()와 OnDamage() 메서드도 [PunRPC]로 선언하여 동기화한다.
        어떤 클라이언트에서 PlayerHP 스크립트의 OnDamage()가 호출되었다고 했을 때, 클라이언트가 호스트가 맞던 아니던 효과음은 실행하고
        체력 슬라이더를 갱신하는 부분은 모두 호스트에서만 제대로 갱신된다.
        즉 OnDamage()가 동시에 실행된다고 가정했을 때, 실제 데미지 적용은 호스트에서만 실행되고 나머지 클라이언트는 겉으로 보이는 효과만 재생된다.


    카메라 컴포넌트
        Rendering Path
            Forward
                각 물체의 셰이더가 개별적으로 렌더링되는 방식.
                조명 수가 적을 때 효율적.
            Deferred
                조명 정보를 버퍼에 저장하고, 물체의 셰이더는 조명 정보를 참조하여 렌더링되는 방식.
                조명 수가 많을 때 효율적.
                우선 물체의 셰이더를 렌더링하고, 조명 정보를 후속 처리하는 방식.
                메모리 사용량이 많고, 투명 물체의 렌더링 처리에 제한이 있을 수 있음.
            Legacy Vertex Lit
                조명 계산이 Vertex Shader에서 이루어지는 방식.
                조명 정보를 버텍스 단위로 계산하므로, 조명 정보가 부드럽게 전달되지 않을 수 있음.
                세밀한 조명 효과를 표현하기 어렵지만, 빠른 렌더링 속도를 제공.
            Use Graphics Settings (Default)
                Project Settings의 Graphics에서 설정한 Rendering Path를 사용한다.

    유니티 포스트 프로세싱이란?
    유니티 포스트 프로세싱은 유니티의 렌더링 파이프라인의 마지막 단계로, 렌더링된 이미지에 후처리 효과를 적용하는 기술.
    이를 통해 렌더링된 이미지에 더 다양한 효과를 적용할 수 있으며, 더욱 생동감 있는 게임 화면을 만들 수 있음.
    포스트 프로세싱 효과에는
        Bloom, Color Grading, Depth of Field, Motion Blur, Glare, Vignette 등 다양한 효과가 있음.

        Bloom : 밝은 빛이나 광원 주변에 흐릿한 효과를 적용하여 빛이 반사되는 느낌을 줌.
        Color Grading : 화면의 색조나 채도를 조절하여 화면의 분위기를 변경.
        Depth of Field : 초점을 맞추는 효과로, 초점을 맞춘 물체 주변이 흐릿하게 표현됨.
        Motion Blur : 물체가 움직일 때 물체 주변에 흐릿한 효과를 적용하여 움직임을 부드럽게 표현.
        Glare : 빛이나 광원 주변에 반사되는 효과를 적용하여 빛이 반사되는 느낌을 줌.
        Vignette : 화면의 주변을 어둡게 처리하여 중심에 초점을 맞추는 효과를 줌.
        Grain : 화면에 노이즈 효과를 적용하여 화면의 질감을 변경.